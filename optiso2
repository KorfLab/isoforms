#!/usr/bin/env python3
import argparse
import json
import os
import random
import sys

import isoform
from isoform import Locus

# Global Memoizers
ACC = dict()
DON = dict()
EXS = dict()
INS = dict()
EXL = dict()
INL = dict()
RNASEQ = dict()

def set_fitness(guy, gene):

    # re-score the transcripts with guy's weights
    # compare tx probabilities to RNA-Seq
	guy['fitness'] = 1
	

def random_guy():
	return {
		'wacc': random.random(),
		'wdon': random.random(),
		'wexs': random.random(),
		'wins': random.random(),
		'wexl': random.random(),
		'winl': random.random(),
		'winf': random.random(),
		'fitness': None,
	}

def mate(p1, p2, mut):
	child = {
		'genotype': {},
		'fitness': None
	}

	weight = ('--wdpwm', '--wapwm', '--wemm', '--wimm', '--welen', '--wilen',
		'--icost')
	for k in weight:
		if random.random() < 0.5: child['genotype'][k] = p1['genotype'][k]
		else:                     child['genotype'][k] = p2['genotype'][k]
		if random.random() < mut: child['genotype'][k] = random.random();

	return child

# CLI

parser = argparse.ArgumentParser(
	description='Parameter optimization program')
parser.add_argument('fasta')
parser.add_argument('gff')
parser.add_argument('model', help='splice model file')
parser.add_argument('--limit', type=int, help='limit number of isoforms')
parser.add_argument('--min_intron', required=False, type=int, default=35,
	metavar='<int>', help='minimum length of intron [%(default)i]')
parser.add_argument('--min_exon', required=False, type=int, default=25,
	metavar='<int>', help='minimum length exon [%(default)i]')
parser.add_argument('--flank', required=False, type=int, default=99,
	metavar='<int>', help='genomic flank on each side [%(default)i]')
parser.add_argument('--pop', required=False, type=int, default=100,
	metavar='<int>', help='population size [%(default)i]')
parser.add_argument('--gen', required=False, type=int, default=100,
	metavar='<int>', help='generations [%(default)i]')
parser.add_argument('--die', required=False, type=float, default=0.5,
	metavar='<int>', help='fraction that die each gen [%(default).2f]')
parser.add_argument('--mut', required=False, type=float, default=0.1,
	metavar='<int>', help='mutation frequency [%(default).2f]')
parser.add_argument('--seed', required=False, type=int,
	metavar='<int>', help='random seed')
parser.add_argument('--name', required=False, type=str, default='',
	metavar='<int>', help='name the output')
parser.add_argument('--verbose', action='store_true', help='show progress')
arg = parser.parse_args()

# Initialize
name, seq = next(isoform.read_fasta(arg.fasta))
model = isoform.read_splicemodel(arg.model)
gene = Locus(name, seq, model, None, None, limit=arg.limit)

# Model score memoizers
for tx in gene.isoforms:
	for beg, end in tx['introns']:
		apos = end - len(model['acc']) +1
		dpos = beg
		size = end - beg + 1
		if size not in INL:
			INL[size] = isoform.score_len(model['inl'], size)
		if apos not in ACC:
			ACC[apos] = isoform.score_pwm(model['acc'], tx['seq'], apos)
		if dpos not in DON:
			DON[dpos] = isoform.score_pwm(model['don'], tx['seq'], dpos)
		if (beg,end) not in INS:
			INS[(beg,end)] = isoform.score_markov(model['ins'], tx['seq'],
				beg + len(model['don']), end - len(model['acc']))
	for beg, end in tx['exons']:
		if (beg,end) not in EXS:
			EXS[(beg,end)] = isoform.score_markov(model['exs'], tx['seq'],
				beg, end)
		size = end - beg + 1
		if size not in EXL:
			EXL[size] = isoform.score_len(model['exl'], size)

# RNASEQ memoizer
# read in the RNA-seq values and convert to probabilities
# need our own Manhattan comparer


sys.exit()

if arg.seed: random.seed(arg.seed)
pop = []
for i in range(arg.pop): pop.append(random_guy())
for guy in pop: set_fitness(guy, gene, model)

# Evolve population

half = int(len(pop) * arg.die)
for g in range(arg.gen):
	pop = sorted(pop, key=lambda item: item['fitness'])
	if arg.verbose: print(f'generation: {g}, fitness: {pop[0]["fitness"]}')

	# mate
	children = []
	for i in range(half, len(pop)):
		p1 = random.randint(0, half)
		p2 = random.randint(0, half)
		pop[i] = mate(pop[p1], pop[p2], arg.mut)
		children.append(pop[i])

	# fitness
	for child in children: child['fitness'] = get_fitness(child, model)

# Final report

pop = sorted(pop, key=lambda item: item['fitness'])
best = pop[0]
print(f'{best["fitness"]:.4f}', end='\t')
for prop, val in best['genotype'].items():
	print(f'{val:.4f}', end='\t')
print(arg.name)
